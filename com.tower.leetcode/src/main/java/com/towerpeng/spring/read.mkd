Spring 是一个企业级java 应用框架，他的作用主要是简化软件的开发以及配置过程，简化项目部署环境；
Spring的优点：
1、spring低侵入设计，对业务代码的污染非常低
2、spring的di机制将对象之间的关系交由框架处理，减少组件的耦合
3、spring提供了aop技术，支持将一些通用的功能进行集中式管理，从而提供更好的复用
4、spring对于主流的框架提供了非常好的支持
IOC就是控制反转，指创建对象的控制权转移给spring来进行管理，简单来说，就是应用不用去new对象了，而全部交由spring自动生产
IOC有三种注入方式：1、构造器注入，2、setter方法注入，3、根据注解注入

Aop面向切面，用于将那些与业务无关，但却对多个对象产生影响的公共行为，抽取并封装成一个可重用的模块，AOP的核心就是动态代理，jdk的动态代理和cglib的动态代理。
Spring AOP 框架提供了基于代理的 AOP 解决方案，Spring AOP 框架基于动态代理，使用 AOP 代理对象来拦截方法调用，从而实现 AOP 功能。


Spring 通过三级缓存（three-level cache）机制来解决循环依赖问题。
这里主要讨论单例Bean的循环依赖。Spring容器在创建Bean的过程中，使用了三个缓存来存储不同状态的Bean实例，从而允许提前暴露尚未完全初始化的Bean实例，供其他Bean引用。

三级缓存：
一级缓存（singletonObjects）：存储完全初始化好的Bean。
二级缓存（earlySingletonObjects）：存储提前暴露的Bean（已经实例化，但尚未填充属性和初始化）。
三级缓存（singletonFactories）：存储Bean工厂，用于生成提前暴露的Bean（通过ObjectFactory包装）。

解决循环依赖的过程（以A依赖B，B依赖A为例）：

开始创建A，实例化A（调用构造器），然后将A的ObjectFactory放入三级缓存（此时A尚未填充属性，也未初始化）。

填充A的属性，发现依赖B，于是尝试获取B。

开始创建B，实例化B，然后将B的ObjectFactory放入三级缓存。

填充B的属性，发现依赖A，于是尝试获取A。

获取A：从一级缓存中未找到，从二级缓存中未找到，从三级缓存中找到A的ObjectFactory，通过它获取到A的早期引用（此时A还未完全初始化），将A放入二级缓存，并从三级缓存移除A的ObjectFactory。

B获取到A的早期引用，完成B的属性填充，然后初始化B，将B放入一级缓存（同时从二级和三级缓存移除B）。

A获取到B（此时B已在一级缓存中），完成A的属性填充，然后初始化A，将A放入一级缓存（同时从二级和三级缓存移除A）。

这样，循环依赖就被解决了。

注意：Spring只能解决单例Bean通过setter注入（或者字段注入）形成的循环依赖，无法解决构造器注入形成的循环依赖。因为构造器注入在实例化时就需要完成注入，而此时Bean还未实例化，无法提前暴露引用。

此外，原型（prototype）作用域的Bean也无法解决循环依赖，因为Spring不会缓存原型Bean，每次都是新建。