Spring 通过三级缓存（three-level cache）机制来解决循环依赖问题。
这里主要讨论单例Bean的循环依赖。Spring容器在创建Bean的过程中，使用了三个缓存来存储不同状态的Bean实例，从而允许提前暴露尚未完全初始化的Bean实例，供其他Bean引用。

三级缓存：
一级缓存（singletonObjects）：存储完全初始化好的Bean。
二级缓存（earlySingletonObjects）：存储提前暴露的Bean（已经实例化，但尚未填充属性和初始化）。
三级缓存（singletonFactories）：存储Bean工厂，用于生成提前暴露的Bean（通过ObjectFactory包装）。

解决循环依赖的过程（以A依赖B，B依赖A为例）：

开始创建A，实例化A（调用构造器），然后将A的ObjectFactory放入三级缓存（此时A尚未填充属性，也未初始化）。

填充A的属性，发现依赖B，于是尝试获取B。

开始创建B，实例化B，然后将B的ObjectFactory放入三级缓存。

填充B的属性，发现依赖A，于是尝试获取A。

获取A：从一级缓存中未找到，从二级缓存中未找到，从三级缓存中找到A的ObjectFactory，通过它获取到A的早期引用（此时A还未完全初始化），将A放入二级缓存，并从三级缓存移除A的ObjectFactory。

B获取到A的早期引用，完成B的属性填充，然后初始化B，将B放入一级缓存（同时从二级和三级缓存移除B）。

A获取到B（此时B已在一级缓存中），完成A的属性填充，然后初始化A，将A放入一级缓存（同时从二级和三级缓存移除A）。

这样，循环依赖就被解决了。

注意：Spring只能解决单例Bean通过setter注入（或者字段注入）形成的循环依赖，无法解决构造器注入形成的循环依赖。因为构造器注入在实例化时就需要完成注入，而此时Bean还未实例化，无法提前暴露引用。

此外，原型（prototype）作用域的Bean也无法解决循环依赖，因为Spring不会缓存原型Bean，每次都是新建。