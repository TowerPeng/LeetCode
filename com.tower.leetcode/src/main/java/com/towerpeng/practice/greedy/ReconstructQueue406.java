package com.towerpeng.practice.greedy;

import java.util.Arrays;
import java.util.LinkedList;

/**
 * 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
 *
 * 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
 *
 * 示例 1：
 *
 * 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
 * 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
 * 解释：
 * 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
 * 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
 * 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
 * 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
 * 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
 * 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
 * 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
 * 示例 2：
 *
 * 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
 * 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
 *
 * @Author: 彭涛
 * @Date: 2026/2/2 18:18
 */
public class ReconstructQueue406 {

    /**
     * people = [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
     * 排序规则：
     * 1. 身高从高到低：7 > 6 > 5 > 4
     * 2. 身高相同时，k值从小到大
     *
     * 排序后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]
     * 初始化：que = []
     *
     * 1. 插入 [7,0]: k=0 → que.add(0, [7,0]) → que = [[7,0]]
     *    解释：7最高，k=0，应该在最前面
     *
     * 2. 插入 [7,1]: k=1 → que.add(1, [7,1]) → que = [[7,0], [7,1]]
     *    解释：第二个7，前面应该有1个身高≥7的人，所以放在索引1
     *
     * 3. 插入 [6,1]: k=1 → que.add(1, [6,1]) → que = [[7,0], [6,1], [7,1]]
     *    解释：6前面应该有1个身高≥6的人，所以放在索引1，[7,1]被后移
     *
     * 4. 插入 [5,0]: k=0 → que.add(0, [5,0]) → que = [[5,0], [7,0], [6,1], [7,1]]
     *    解释：5前面应该有0个身高≥5的人，所以放在最前面
     *
     * 5. 插入 [5,2]: k=2 → que.add(2, [5,2]) → que = [[5,0], [7,0], [5,2], [6,1], [7,1]]
     *    解释：5前面应该有2个身高≥5的人，所以放在索引2
     *
     * 6. 插入 [4,4]: k=4 → que.add(4, [4,4]) → que = [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
     *    解释：4前面应该有4个身高≥4的人，所以放在索引4
     *
     *    输出：[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
     *
     *
     * @param people
     * @return
     */
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列
            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列
        });
        LinkedList<int[]> que = new LinkedList<>();

        // 3. 遍历排序后的 people 数组
        for (int[] p : people) {
            // 4. 将当前人插入到队列中索引为 p[1] 的位置
            //    p[1] 就是 k 值，表示前面应该有 k 个身高 >= 当前身高的人
            //    由于我们已经按身高降序排列，所以前面插入的人身高都 >= 当前人
            //    因此只需插入到第 k 个位置即可满足条件
            //    例子：que.add(2, [5,2])
            que.add(p[1], p);

            // LinkedList.add(index, element) 的工作原理：
            // 在指定索引处插入元素，将该位置及之后的元素向右移动
            // 例如：que = [A, B, C], que.add(1, X) → que = [A, X, B, C]
        }
        // 5. 将 LinkedList 转换为二维数组返回
        //    toArray(new int[people.length][]) 会自动填充数组
        return que.toArray(new int[people.length][]);
    }
}
